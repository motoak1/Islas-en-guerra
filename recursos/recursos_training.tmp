// Funciones de entrenamiento de tropas
bool entrenarObrero(struct Jugador *j, float x, float y) {
  // Buscar un espacio disponible en el array de obreros
  for (int i = 0; i < 6; i++) {
    // Si el obrero está en posición (0,0) y no está moviéndose, está "muerto" o no usado
    if (j->obreros[i].x == 0 && j->obreros[i].y == 0 && !j->obreros[i].moviendose) {
      // Obtener la posición del cuartel
      if (j->cuartel == NULL)
        return false;
      
      Edificio *cuartel = (Edificio *)j->cuartel;
      
      // Generar posición cerca del cuartel (offset aleatorio pequeño)
      float offsetX = (float)((i % 3) * 70); // 0, 70, 140
      float offsetY = (float)((i / 3) * 70); // 0, 0, 0, 70, 70, 70
      
      j->obreros[i].x = cuartel->x + offsetX;
      j->obreros[i].y = cuartel->y + cuartel->alto + 20 + offsetY;
      j->obreros[i].destinoX = j->obreros[i].x;
      j->obreros[i].destinoY = j->obreros[i].y;
      j->obreros[i].moviendose = false;
      j->obreros[i].seleccionado = false;
      j->obreros[i].dir = DIR_FRONT;
      j->obreros[i].frame = 0;
      j->obreros[i].celdaFila = -1;
      j->obreros[i].celdaCol = -1;
      j->obreros[i].rutaCeldas = NULL;
      j->obreros[i].tipo = TIPO_OBRERO;
      j->obreros[i].animActual = animPorDireccion(DIR_FRONT);
      
      printf("[CUARTEL] Nuevo obrero entrenado en posición (%.1f, %.1f)\n", 
             j->obreros[i].x, j->obreros[i].y);
      return true;
    }
  }
  
  // No hay espacio disponible
  return false;
}

bool entrenarCaballero(struct Jugador *j, float x, float y) {
  // Buscar un espacio disponible en el array de caballeros
  for (int i = 0; i < 4; i++) {
    // Si el caballero está en posición (0,0) y no está moviéndose
    if (j->caballeros[i].x == 0 && j->caballeros[i].y == 0 && !j->caballeros[i].moviendose) {
      // Obtener la posición del cuartel
      if (j->cuartel == NULL)
        return false;
      
      Edificio *cuartel = (Edificio *)j->cuartel;
      
      // Generar posición cerca del cuartel
      float offsetX = (float)((i % 2) * 70); // 0, 70, 0, 70
      float offsetY = (float)((i / 2) * 70); // 0, 0, 70, 70
      
      j->caballeros[i].x = cuartel->x + offsetX;
      j->caballeros[i].y = cuartel->y + cuartel->alto + 20 + offsetY;
      j->caballeros[i].destinoX = j->caballeros[i].x;
      j->caballeros[i].destinoY = j->caballeros[i].y;
      j->caballeros[i].moviendose = false;
      j->caballeros[i].seleccionado = false;
      j->caballeros[i].dir = DIR_FRONT;
      j->caballeros[i].frame = 0;
      j->caballeros[i].celdaFila = -1;
      j->caballeros[i].celdaCol = -1;
      j->caballeros[i].rutaCeldas = NULL;
      j->caballeros[i].tipo = TIPO_CABALLERO;
      j->caballeros[i].animActual = animPorDireccion(DIR_FRONT);
      
      printf("[CUARTEL] Nuevo caballero entrenado en posición (%.1f, %.1f)\n", 
             j->caballeros[i].x, j->caballeros[i].y);
      return true;
    }
  }
  
  // No hay espacio disponible
  return false;
}
